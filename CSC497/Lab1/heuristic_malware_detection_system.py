#!/usr/bin/env python3.6
from __future__ import absolute_import, division, print_function
import pefile
import re
import collections as col
from collections import Counter
import os

folder = '/home/ec2-user/Lab1/Malware'

class MalwareFunctions():
    def __init__(self, pathMalware, address, name, ordinal):
        self.pathMalware = pathMalware
        self.address = address
        self.name = name
        self.ordinal = ordinal
 
    def __repr__(self):
        return 'MalwareFunctions(%r, %r, %r, %r)' %(self.pathMalware, \
                self.address, self.name, self.ordinal)
  
    #This function displays the absolute path of all the malware inside the folders
    def display_malware_files():
        list_all_malwares = []
        for hash in os.listdir(folder):
            malware_file_abspath = os.path.join(folder, hash)
            list_all_malwares.append(malware_file_abspath)
        return list_all_malwares
 
    #This function helps to extract the list of all the functions of the Malware
    def enum_export(malware_file):
        functions = []
        pe = pefile.PE(malware_file)
        if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                functions.append({'address': (hex(exp.address \
                    + pe.OPTIONAL_HEADER.ImageBase)), \
                        'name': exp.name, 'ordinal': exp.ordinal })
            return functions
  
    #This function counts the number of occurence of each memory address
    def count_memory_address(memory_list):
        for memory in memory_list:
            if memory_list.count(memory) >= 3:
                print('\t\t|-->Memory: %s ===> %d' %(memory, \
                    +memory_list.count(memory)))
 
    #This function checks if two or more export functions have the same name.
    def count_function_name(function_name_list):
        for name in function_name_list:
            if function_name_list.count(name) >= 2:
                print('\t\t|-->Name %s ===> %d' %(name,\
                    +function_name_list.count(name)))
  
    #This function checks if three or more functions have the same memory offset.
    def count_function_memory_offset(function_name_list):
        total_offset = 0
        for name in function_name_list:
            offset = name[8:13]
            if offset in name:
                total_offset += 1
                
        if total_offset >= 3:
            print("\t\t|-->Counter memory offset %s is: %d" %(offset, total_offset))
                
if __name__ == '__main__':
    
    print('Beginning Heuristic Malware Detection System... \n')
    
    #Display the list of the absolute path of all the malwares
    for malware in MalwareFunctions.display_malware_files():
        print('\nMalware[]: %s' %( malware))
        print('\n \t Total of functions: %d \n' %len(MalwareFunctions.enum_export(malware)))
            memory_address_list = []
            function_name_list = []
            
            for item in MalwareFunctions.enum_export(malware):
                #print("\tAddress: %s -- Name: %s -- Ordinal: %s" %(item['address'], item['name'], item['ordinal']))
                memory_address_list.append("Address: %s" %item['address'])
                function_name_list.append("Name: %s" %item['name'])
        
        print("\n\tMalware Analysis Results ")
        print("\t#Checking if three or more export functions have the same memory address__\n")
        MalwareFunctions.count_memory_address(memory_address_list)
  
        print("\t#Checking if two or more export functions have the same name__\n")
        MalwareFunctions.count_function_name(function_name_list)
  
        print("\t#Checking if three or more export functions have the same offset__\n")
        MalwareFunctions.count_function_memory_offset(memory_address_list)
